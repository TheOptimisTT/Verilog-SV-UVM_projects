=============== 11.03 ===============
=============== 11.03 ===============
=============== 11.03 ===============

Data Hazard 3 Data Forwarding
    Как правим запис в нашата памет. И как да предотвратим неправилни записи.
        Ако има невалидни инструкции трябва да пречим на тези инструкции да направят запис в нашата памет
    
    Това което можем да направим е да сложим още 1 бит към инструкцията която показва дали е валидна или не.
    Това означава че тази инструкция има WriteEnable

    Когато ресетнем системата паиплайна е пълен с нули и правим запис на адрес 0, но сега като имаме валид = 0,
    няма да има WE и няма да запише в паметта. Другия ефект е че ако има невалидна инструцкия нейнато стойност 
    няма да бъде записана в паметта. Също така ако има навалиден бранч няма да има невалидни записи.

    Какво означава валидна инструкция?

    Как може да накараме нашия процесор да изпулнява повече от 1 инструкция ?
        - трябва да решим какви инструкции искаме да добавим.
      
        
Processor with 8 instructions and 1 operand
    - трябва да модифицираме new instruction format - adding 3 bits to code the different instructions
        IW[10:8] = CMD_ID[2:0]
        IW[7:0] = OP_ID[7:0]
        IW[10:0] = {...}
    - Addinf ALU in the place of the adder. има 3 управляващи бита който се подават по s1-s3 reg.
          - instructions
            inc             3'b000, 
            dec             3'b001, 
            invert          3'b010, 
            reductoin OR    3'b011, 
            reduction AND   3'b100,
    - Новия модул АЛУ има 1 вход по който идват данните, команден интерфейс
      по който идва действието което ще се извърши, има и изход по който ще минат данните след обработка

Processor Enchancement: Adding more opperands. Processor with 7 instrucitons and 2 operands
    Update instruciton format
        IW[18:16] = CMD_ID[2:0]

        IW[15:8] = OP1_ID[7:0]
        IW[7:0] = OP0_ID[7:0]

        IW[18:0] = {CMD_ID, OP1_ID, OP0_ID}
    Като сме дефинирали новия IW се връщаме към конвеира и трябва да дефинираме още 1 входен регистър.

    Нашата памет трябва да се промени малко за да може да обслужва и другия операнд ака да може да го чете записването няма да
    бъде афектирано защото резултата ще е все още само един. Трябва да стане 3 портова памет.

    ДРуго което променяме е самото АЛУ. Трябва да добавим още 2 команди и още 1 вход.

    Никога 2рия операнд не трябва да зависи от резултата. Трябва така да напишем нашата програма че никога да не се получава запис
    на един от адресите от който четем операндите. 

    Друг проблем е че ние имаме резултат и винаги го записваме в адреса на операнд 0. Това е ограничение което трябва да се реши.
    В масата от случайте искам да вземем 2 числа да извършим операция на тях и да ги запишем в друг свободен адрес.
    Трябва да се добави опцията за запис в конкретен адрес. Затова се дефинира още едно поле което указва на кой адре
    ще има запис

        Update instruciton format
                IW[:]   = CMD_ID[2:0]
                IW[:]   = OP1_ID[7:0]
                IW[:]   = RSLT0_ID[7:0]
                IW[7:0] = OP0_ID[7:0]

                IW[18:0] = {CMD_ID, OP1_ID, OP0_ID}

    Единствения дефиция който има след това е че втория операнд няма data Forwarding. Което означава че трябва да добавим DF.

    След тази променя вече имаме един легитимин конвеир, който работи с 2 операнда и има 8 инструкции



    // Друия път ще довършим това кодиране. Да се опитаме да подкараме симулациите до сега.
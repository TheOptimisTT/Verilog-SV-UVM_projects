=============== 11.03 ===============
=============== 11.03 ===============
=============== 11.03 ===============

Data Hazard 3 Data Forwarding
    Как правим запис в нашата памет. И как да предотвратим неправилни записи.
        Ако има невалидни инструкции трябва да пречим на тези инструкции да направят запис в нашата памет
    
    Това което можем да направим е да сложим още 1 бит към инструкцията която показва дали е валидна или не.
    Това означава че тази инструкция има WriteEnable

    Когато ресетнем системата паиплайна е пълен с нули и правим запис на адрес 0, но сега като имаме валид = 0,
    няма да има WE и няма да запише в паметта. Другия ефект е че ако има невалидна инструцкия нейнато стойност 
    няма да бъде записана в паметта. Също така ако има навалиден бранч няма да има невалидни записи.

    Какво означава валидна инструкция?

    Как може да накараме нашия процесор да изпулнява повече от 1 инструкция ?
        - трябва да решим какви инструкции искаме да добавим.
      
        
Processor with 8 instructions and 1 operand
    - трябва да модифицираме new instruction format - adding 3 bits to code the different instructions
        IW[10:8] = CMD_ID[2:0]
        IW[7:0] = OP_ID[7:0]
        IW[10:0] = {...}
    - Addinf ALU in the place of the adder. има 3 управляващи бита който се подават по s1-s3 reg.
          - instructions
            inc             3'b000, 
            dec             3'b001, 
            invert          3'b010, 
            reductoin OR    3'b011, 
            reduction AND   3'b100,
    - Новия модул АЛУ има 1 вход по който идват данните, команден интерфейс
      по който идва действието което ще се извърши, има и изход по който ще минат данните след обработка

Processor Enchancement: Adding more opperands. Processor with 7 instrucitons and 2 operands
    Update instruciton format
        IW[18:16] = CMD_ID[2:0]

        IW[15:8] = OP1_ID[7:0]
        IW[7:0] = OP0_ID[7:0]

        IW[18:0] = {CMD_ID, OP1_ID, OP0_ID}
    Като сме дефинирали новия IW се връщаме към конвеира и трябва да дефинираме още 1 входен регистър.

    Нашата памет трябва да се промени малко за да може да обслужва и другия операнд ака да може да го чете записването няма да
    бъде афектирано защото резултата ще е все още само един. Трябва да стане 3 портова памет.

    ДРуго което променяме е самото АЛУ. Трябва да добавим още 2 команди и още 1 вход.

    Никога 2рия операнд не трябва да зависи от резултата. Трябва така да напишем нашата програма че никога да не се получава запис
    на един от адресите от който четем операндите. 

    Друг проблем е че ние имаме резултат и винаги го записваме в адреса на операнд 0. Това е ограничение което трябва да се реши.
    В масата от случайте искам да вземем 2 числа да извършим операция на тях и да ги запишем в друг свободен адрес.
    Трябва да се добави опцията за запис в конкретен адрес. Затова се дефинира още едно поле което указва на кой адре
    ще има запис

        Update instruciton format
                IW[:]   = CMD_ID[2:0]
                IW[:]   = OP1_ID[7:0]
                IW[:]   = RSLT0_ID[7:0]
                IW[7:0] = OP0_ID[7:0]

                IW[18:0] = {CMD_ID, OP1_ID, OP0_ID}

    Единствения дефиция който има след това е че втория операнд няма data Forwarding. Което означава че трябва да добавим DF.

    След тази променя вече имаме един легитимин конвеир, който работи с 2 операнда и има 8 инструкции

За момента нямаме 2 неща което го различава от нормален процесор. 
Това са Branch + Flush(Инвалидиране на данни), Stall (Външна памент или Load/Store Unit)

// Друия път ще довършим това кодиране. Да се опитаме да подкараме симулациите до сега.

// Да видя презентацията за да видя промените в АЛУ, Новия Instruction Word и да добавя MUX-вете от новата схема.
// (5-stage-pipeline, OP1_ID, OP0_ID, RSLT_ID, more muxes)


================  18.03  ================
================  18.03  ================
================  18.03  ================


Pipeline processor design
Processor with 7 instrucitons and 2 opperand
    ALU UPDATE:
        -ADD, SUB
    2port Mem updata -> REG FILE(3port mem)
        - new file with 3port module
    New data Forwarding for op1.
    Word Update:
        - Result_ID

5 STAGE Pipeline 

================  19.03  ================
================    СУ   ================
================  19.03  ================
Основната функция на процесора който правим е да брой броя подадени
    инструкции към оригиналния процесор. Затова всяка инструкция към оригиналния процесор се явява адрес в нашия процесор.

Защо ICODE се подава на реад порта на MEM?
    - Защото искаме да прочетем какво е записано в нашата памет.

В базовия модел записа се извършва в клетката която е прочетена в началото.

Защо има ByPass reg ?
    Защото ние бройм в кой Stage се случват промените 


================  25.03  ================
================    Л    ================
================  25.03  ================

Processor Enchancement: Loading operands

Създаване и деклариране на Load & Store Controller
Създаване И деклариране на Instruction Fetch stages (2)
